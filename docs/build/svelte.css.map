{
  "version": 3,
  "file": "svelte.css",
  "sources": [
    "../../component.svelte"
  ],
  "sourcesContent": [
    "<style>button{font-weight:700;padding:.5rem 1rem;border-radius:.25rem;--bg-opacity:1;background-color:#4299e1;background-color:rgba(66,153,225,var(--bg-opacity));--text-opacity:1;color:#fff;color:rgba(255,255,255,var(--text-opacity))}button:disabled{--bg-opacity:1;background-color:#4a5568;background-color:rgba(74,85,104,var(--bg-opacity));cursor:not-allowed}button:hover:enabled{--bg-opacity:1;background-color:#2b6cb0;background-color:rgba(43,108,176,var(--bg-opacity))}button:focus{outline:0}input{width:100%}</style>\n\n<script>\n    import * as workerTimers from \"worker-timers\";\n    import {get, writable} from 'svelte/store';\n\n    let minDurationSeconds = writable(180);\n    let maxDurationSeconds = writable(900);\n    let strokesPerMinute = 100;\n    let volume = 0.8;\n    let counter = 0;\n    let countDown = 4;\n    let minFormattedDuration = writable(\"\");\n    let maxFormattedDuration = writable(\"\");\n    let targetCount = 0;\n\n    let intervalId;\n    let running = false;\n    let testing = false;\n\n    const cum = new Howl({\n        src: [\"assets/cum.mp3\"]\n    });\n\n    const synth = new Tone.Synth({\n        oscillator: {\n            type: 'triangle',\n            modulationType: 'sine',\n            modulationIndex: 3,\n            harmonicity: 3.4\n        },\n        envelope: {\n            attack: 0.001,\n            decay: 0.1,\n            sustain: 0.01,\n            release: 0.1\n        }\n    }).toDestination();\n\n    const playBeat = () => {\n        synth.triggerAttackRelease('A1', '16n');\n    }\n\n    const playBeep = () => {\n        synth.triggerAttackRelease('C3', '4n');\n    }\n\n    const playStartBeep = () => {\n        synth.triggerAttackRelease('C5', '4n');\n    }\n\n    const start = () => {\n        running = true;\n        const targetSeconds = Math.random() * ($maxDurationSeconds - $minDurationSeconds) + $minDurationSeconds;\n        targetCount = Math.round(targetSeconds * strokesPerMinute / 60);\n        intervalId = workerTimers.setInterval(function beatLoop() {\n            if (countDown > 0) {\n                countDown = countDown - 1;\n            } else {\n                counter = counter + 1;\n            }\n            if (counter === targetCount) {\n                cum.play();\n                stop();\n            } else {\n                if (countDown > 0) {\n                    playBeep();\n                } else if (countDown === 0 && counter === 0) {\n                    playStartBeep();\n                } else {\n                    playBeat();\n                }\n            }\n            return beatLoop;\n        }(), 60 / strokesPerMinute * 1000);\n    }\n\n    const stop = () => {\n        running = false;\n        counter = 0;\n        countDown = 4;\n        workerTimers.clearInterval(intervalId);\n    }\n\n    const restart = () => {\n        if (running) {\n            stop();\n            start();\n        }\n    }\n\n    const test = () => {\n        testing = true;\n        targetCount = 3\n        intervalId = workerTimers.setInterval(function testBeatLoop() {\n            counter = counter + 1;\n            playBeat();\n            if (counter === targetCount) {\n                testing = false;\n                stop();\n            }\n            return testBeatLoop;\n        }(), 60 / strokesPerMinute * 1000);\n    }\n\n    $: if (strokesPerMinute) {\n        restart();\n    }\n\n    $: if (volume) {\n        synth.volume.value = -20 + (21 * volume);\n        Howler.volume(volume);\n    }\n\n    minDurationSeconds.subscribe(() => {\n        if ($minDurationSeconds <= 60) {\n            minFormattedDuration.set(`${$minDurationSeconds} seconds`);\n        } else {\n            const seconds = ($minDurationSeconds % 60).toString().padStart(2, \"0\");\n            minFormattedDuration.set(`${Math.floor($minDurationSeconds / 60)}:${seconds} minutes`);\n        }\n    });\n\n    $: if ($minDurationSeconds > get(maxDurationSeconds)) {\n        maxDurationSeconds.set($minDurationSeconds);\n    }\n\n    maxDurationSeconds.subscribe(() => {\n        if ($maxDurationSeconds <= 60) {\n            maxFormattedDuration.set(`${$maxDurationSeconds} seconds`);\n        } else {\n            const seconds = ($maxDurationSeconds % 60).toString().padStart(2, \"0\");\n            maxFormattedDuration.set(`${Math.floor($maxDurationSeconds / 60)}:${seconds} minutes`);\n        }\n    });\n\n    $: if ($maxDurationSeconds < get(minDurationSeconds)) {\n        minDurationSeconds.set($maxDurationSeconds);\n    }\n\n\n</script>\n\n<div class=\"container mx-auto px-4 py-4\">\n    <div class=\"grid grid-flow-row gap-4\">\n        <div>\n            {#if !running}\n                <button on:click={start} disabled={testing}>Start</button>\n                <button on:click={test} disabled={testing}>Test (Play 3 beats)</button>\n            {:else}\n                <button on:click={stop}>Stop</button>\n            {/if}\n        </div>\n        {#if running}\n            {#if countDown > 0}\n                <div>\n                    Ready? {countDown}\n                </div>\n            {:else}\n                <div class=\"font-mono\">\n                    Stokes: {counter}\n                </div>\n            {/if}\n        {/if}\n        {#if !running}\n            <div class=\"grid grid-cols-6 gap-4\">\n                <div class=\"col-span-5\">\n                    <label>Minimum Duration\n                        <input step=\"15\" min=\"15\" max=\"1800\" type=\"range\" bind:value={$minDurationSeconds}>\n                    </label>\n                </div>\n                <div class=\"col-span-1 flex pb-1\">\n                    <output class=\"flex self-end\">{$minFormattedDuration}</output>\n                </div>\n            </div>\n            <div class=\"grid grid-cols-6 gap-4\">\n                <div class=\"col-span-5\">\n                    <label>Maximum Duration\n                        <input step=\"15\" min=\"15\" max=\"1800\" type=\"range\" bind:value={$maxDurationSeconds}>\n                    </label>\n                </div>\n                <div class=\"col-span-1 flex pb-1\">\n                    <output class=\"flex self-end\">{$maxFormattedDuration}</output>\n                </div>\n            </div>\n            <div class=\"grid grid-cols-6 gap-4\">\n                <div class=\"col-span-5\">\n                    <label>Strokes per Minute\n                        <input step=\"10\" min=\"10\" max=\"400\" type=\"range\" bind:value={strokesPerMinute}>\n                    </label>\n                </div>\n                <div class=\"col-span-1 flex pb-1\">\n                    <output class=\"flex self-end\">{strokesPerMinute}</output>\n                </div>\n            </div>\n        {/if}\n        <div class=\"grid grid-cols-6 gap-4\">\n            <div class=\"col-span-5\">\n                <label>Volume\n                    <input step=\"0.1\" min=\"0\" max=\"1\" type=\"range\" bind:value={volume}>\n                </label>\n            </div>\n            <div class=\"col-span-1 flex pb-1\">\n                <output class=\"flex self-end\">{volume * 100}%</output>\n            </div>\n        </div>\n    </div>\n</div>"
  ],
  "names": [],
  "mappings": "AAAO,oBAAM,CAAC,YAAY,GAAG,CAAC,QAAQ,KAAK,CAAC,IAAI,CAAC,cAAc,MAAM,CAAC,aAAa,CAAC,CAAC,iBAAiB,OAAO,CAAC,iBAAiB,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,cAAc,CAAC,CAAC,CAAC,oBAAM,SAAS,CAAC,aAAa,CAAC,CAAC,iBAAiB,OAAO,CAAC,iBAAiB,KAAK,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,OAAO,WAAW,CAAC,oBAAM,MAAM,QAAQ,CAAC,aAAa,CAAC,CAAC,iBAAiB,OAAO,CAAC,iBAAiB,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,oBAAM,MAAM,CAAC,QAAQ,CAAC,CAAC,mBAAK,CAAC,MAAM,IAAI,CAAC"
}